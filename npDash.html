<!DOCTYPE html>
<!-- Initial prototpe of the genome visualisation tool -->
<html lang="en">
    <head>
        <!--<script type="text/javascript" src="d3.min.js"></script>  Local copy-->
        <script src="https://d3js.org/d3.v4.min.js"></script> <!-- Direct link -->
        <style>
            .pairs {
               stroke: #F00;
               stroke-width: 8px;
            }
            .links {
               stroke: #444;
               stroke-width: 1px;
            }
            .node {
              /*cursor: move; */
              fill: #ccc;
              stroke: #000;
              stroke-width: 1.5px;
            }
          
            .node.fixed {
                fill: #f00;
            }
        </style>
    </head>
<body>
    <script>
        /**
         *  Date: 19-SEP-2016
         *  
         */

        /* Set the SVG canvas size */
        var width = 800,
            height = 600;

        /* Specify the SVG canvas */
        var svg = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height);

        /* Specify the forces that will be used by the visualisation */
        var visual = d3.forceSimulation()
            //.nodes(nodes)
            .force("pairs", d3.forceLink().id(function(d) { return d.id; }))
            .force("link", d3.forceLink().id(function(d) { return d.id; }))
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2));
            //.force("collision", d3.forceCollide(2));

        /* Read the JSON file located in the same directory */
        d3.json("assembly.json", function(error, d) {
            if (error) throw error;

            /**
            * Start drawing the nodes
            * In future versions the nodes could be hidden until mouse hover 
            * event.
            */
            //console.log(d.nodes);
            
            var node = svg.selectAll('.node')
                .data(d.nodes)
                .enter().append('circle')
                .attr('class', 'node');

            //console.log(d.nodes);

            visual
                .nodes(d.nodes);

            /**
             * Select and join contig nodes to create the graph edge (DNA sequence).
             * Data (contigData) is bound to the HTML? elements 'pairs'. Drawing 
             * will commence at the start of simulation.
             */
            var pairs = svg.selectAll('.pairs')
                .data(d.contigData)
                .enter().append('line')
                .attr('class', 'pairs');

            /**
             * Scaling the lengths to ensure that the contigs will fit on in the 
             * SVG canvas.
             */
            var lengthScale = d3.scaleLinear()
                .domain([0, d3.max(d.contigData, function(d) {
                    return d.length;
                })])
                .range([0,256]);

            // Draw the contig
            visual.force('pairs')
                .links(d.contigData)
                .distance(function(d,i) {
                    //console.log(d);
                    return lengthScale(d.length);
                })
                .iterations(10); // Enforce the distance (adds runtime cost)


            /* Select and join the contig adjacencies */
            var links = svg.selectAll('.links')
                .data(d.contigLinks)
                .enter().append('line')
                .attr('class', 'links');

                //console.log(d.contigLinks);

            // Draw the contig adjacencies
            visual.force('link')
                .links(d.contigLinks)//;
                .distance(10)   // Also reduce the distance between adj edges
                .iterations(10);    // Maybe add as a user setting

            /**
             * Start the real-time visualisation
             * TODO: Separate this out to a function.
             */
            visual.on('tick', function() {   //'end' or 'tick' can be specified

                node.attr('cx', function(d) { return d.x; })    // Node x-coordinate
                    .attr('cy', function(d) { return d.y; });   // Node y-coordinate
                    //.attr('r', 1)                  // Node radius (Not required)

                pairs.attr('x1', function(d) { return d.source.x; })
                    .attr('y1', function(d) { return d.source.y; })
                    .attr('x2', function(d) { return d.target.x; })
                    .attr('y2', function(d) { return d.target.y; });

                links.attr('x1', function(d) { return d.source.x; })
                    .attr('y1', function(d) { return d.source.y; })
                    .attr('x2', function(d) { return d.target.x; })
                    .attr('y2', function(d) { return d.target.y; });
            }); // End force.on anon function

            /**
             * Specify forces between nodes to prevent them from stacking on each
             * other.
             * Negative strength = repulsion.
             * Positive strength = attraction.
             * manyBody.distanceMin and manyBody.distanceMax used to localise
             * the forces between nearby nodes instead of over the whole
             * visualisation
             */
            visual.force("charge")
                .strength(-40)
                .distanceMin(10)
                .distanceMax(100); // Selected based on trial and error

        }); // End d3.json read
        </script>
    </body>
</html>