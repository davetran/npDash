<!DOCTYPE html>
<!-- Initial prototpe of the genome visualisation tool -->
<html lang="en">
    <head>
        <meta charset="UTF-8"> 
        <script type="text/javascript" src="d3.min.js"></script>  <!--Local copy-->
        <!--<script src="https://d3js.org/d3.v4.min.js"></script> sDirect link -->
        <!-- http://paletton.com/palette.php?uid=7010D0kllllaFw0g0qFqFg0w0aF -->
        <link rel="stylesheet" href="styles.css">
    </head>
<body>
    <!-- npDash-->
    <div class="controls">
        <div class = 'card'>
            <div class = 'cardTitle' style='font-size: 18px'>npDash</div>
        </div>
        <div class = 'card'>
            <div class = 'cardTitle'>Contig Details</div>
            <div class = 'cardLine'>
                <div class = 'cardLineHeader'> Name: </div>
                <div class = 'cardLineContent' id='cName'> --- </div>
            </div>
            <div class = 'cardLine'>
                <div class = 'cardLineHeader'> Length: </div>
                <div class = 'cardLineContent' id='cLength'> --- </div>
            </div>
            <div class = 'cardLine'>
                <div class = 'cardLineHeader'> Coverage: </div>
                <div class = 'cardLineContent' id='cCoverage'> --- </div>
            </div>
        </div>
        <div class = 'card'>
            <div class = 'cardTitle'>Layout controls</div>
            <div class = 'cardLine'>
                <div class = 'cardLineHeader'> Mode: </div>
                    <div class = 'toggleButton' id = 'RealT'> Real-time</div>
                    <div class = 'toggleButton' id = 'Static'> Static</div>
            </div>
            <div class = 'cardLine'>
                <div class = 'cardLineHeader'> Node ID: </div>
                    <div class = 'toggleButton' id = 'Show'> Show</div>
                    <div class = 'toggleButton' id = 'Hide'> Hide</div>
            </div>
        </div>
        <p class = "normal" id="timer">Next update in:</p>

    <script>
        
    // Set default style
    d3.select('#Hide')
        .style('color','#86C98A')
        .style('font-weight', '700');
    d3.select('#Show')
        .style('color','#DDDDDD')
        .style('font-weight', '200');
    d3.select('#RealT')
        .style('color','#DDDDDD')
        .style('font-weight', '200');
    d3.select('#Static')
        .style('color','#86C98A')
        .style('font-weight', '700');

        // Mode toggle button.
        d3.selectAll('#RealT')
            .on('click', function(d) {
                console.log('Responding')

                dynamic = 1;
                // Update the view
                d3.select('#RealT')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
                d3.select('#Static')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');
        });
        d3.selectAll('#Static')
            .on('click', function(d) {
                console.log('Responding')

                dynamic = 0;
                // Update the view
                d3.select('#RealT')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');
                d3.select('#Static')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
        });

        // Hide node names button text thing.
        d3.selectAll('#Hide')
            .on('click', function(d) {
                console.log('Responding')

                // Update the view
                d3.select('#Hide')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
                d3.select('#Show')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');

                pairs.select('text').style('display', 'none');
                pairs2.select('text').style('display', 'none');
        });

        d3.selectAll('#Show')
            .on('click', function(d) {

                // Update the view
                d3.select('#Hide')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');
                d3.select('#Show')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
                pairs.select('text').style('display', 'block');
                pairs2.select('text').style('display', 'block');
                
                //ticked(); // Why was this here in the first place
                console.log(d3.select(this));
        });

        // Hide node names button text thing.
        d3.selectAll('div.hideNodeNames')
            .on('click', function(d) {

                // Update the view
                d3.select('div.hideNodeNames')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
                d3.select('div.showNodeNames p')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');

                pairs.select('text').style('display', 'none');
                pairs2.select('text').style('display', 'none');
                
                console.log(d3.select(this));
        });
        d3.selectAll('div.showNodeNames')
            .on('click', function(d) {
                //d3.select(this).style('font-size','40');

                d3.select('div.hideNodeNames')
                    .style('color','#DDDDDD')
                    .style('font-weight', '200');
                d3.select('div.showNodeNames p')
                    .style('color','#86C98A')
                    .style('font-weight', '700');
                pairs.select('text').style('display', 'block');
                pairs2.select('text').style('display', 'block');
                
                //ticked(); // Why was this here in the first place
                console.log(d3.select(this));
        });

        //Countdown timer
        var x = setInterval(function() {
            if (seconds == 0 ) {
                document.getElementById("timer").innerHTML = "Next update in : Waiting";
            }
            else {
                seconds = seconds - 1;
                document.getElementById("timer").innerHTML = "Next update in: " + seconds;
            }
        }, 1000);

    </script>
    </div><!--id=control-->

    <div id="visual">
    <script>
        /**
         *  Date: 13-MAR-2017
         *  
         */
        
        /* Variable to set the visualisation to reload data */
        var dynamic = 0;
        var clock = 0;

        var offsetsx = 0;
        var offsetsy = 0;
        var offsettx = 0;
        var offsetty = 0;

        var uiIdleTimer = null;

        // Seconds for timer
        var seconds = 10;
        var mouseEvent = 'Null';

        var timerRestart = 0;

        // Create a clock
        setInterval(incrementClock,1000);

        var dragTimer = setInterval(function() {
            if (timerRestart == 0 ) {
                    // Do nothing.
                }
                else {
                    timerRestart = timerRestart - 1;
                }
            }, 1000);


        /* Set the SVG canvas size */
        var width = 800,
            height = 700;

        /* Specify the SVG canvas */
        var svg = d3.select('body').append('svg')
            .attr('width', width)
            .attr('height', height)
            .attr('class','visual');

        /* Specify the forces that will be used by the visualisation */
        var visual = d3.forceSimulation()
            //.nodes(nodes)
            .force("pairs", d3.forceLink().id(function(d) { return d.id; }))
            .force("link", d3.forceLink().id(function(d) { return d.id; }))
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("x", d3.forceX())
            .force("y", d3.forceY())
            .on('tick', null)   // Set the callback as null. This will change when we drag
            .on('end', function() {end(0)}); // 'end'
            //.force("collision", d3.forceCollide(2));
        
        visual.stop();

        /* Selections */
        var node = svg.selectAll('.node');
        var pairs = svg.selectAll('.pairs');
        var links = svg.selectAll('.links');

        var nodeName = svg.append('g')
        var currentID = 'Placeholder details';

        nodeName.attr('class', 'nodeID')
                .attr('x', 00)
                .attr('y', 680);
        
        nodeName.append('text')
                .text(function(d) {return currentID})
                .attr('x', 5)
                .attr('y', 695);

        /* Read the JSON file located in the same directory */
        d3.json("assembly.json", function(error, d) {
            if (error) throw error;

            /* Update the data using the JSON */
            update(d);
            /* Re-energise the simulation */
            visual.alpha(1).restart();

        }); // End d3.json read

        /* This block of code will continuously operate to provide real-time functionality 
         * using the javascript method setInterval().
         */
        var updater = setInterval(function() {
            dynamicUpdate();
        }, 10000); // Refresh once every 30 seconds

        /**
         * Update function 
         * Uses the data read in the JSON file to peform the 'General update pattern'
         * See: https://bl.ocks.org/mbostock/3808221
         * See: https://bost.ocks.org/mike/selection/
         * See: https://bost.ocks.org/mike/join/
         */
        function update(d) {
            console.log('Updating')
            /* Updates the nodes */
            // Bind the data stored in the JSON nodes object.
            node = node.data(d.nodes, function(d) {return d.id; });
            
            // Remove nodes with no data associated
            node.exit().remove().transition().duration(1000);

            // Build the elements for the new nodes
            var node2 = node.enter().append('g')
                .attr('class', 'node')

            node2.append('circle');
            // Merge the new nodes into the main selection.
            node = node.merge(node2);

            /* Update the contigs */
            // TODO rename pairs to contigs
            // Bind the data
            pairs = pairs.data(d.contigData);

            // When no new contigs are detected, then we will ensure
            // that the colour for the new contigs are not changed
            if (pairs.enter().size() != 0) {
                pairs.attr('class', 'pairs');
            }
            // Perform the exit() operation
            pairs.exit()
                 .attr('class', 'pairs')
                 .transition()
                 .attr("y", 60)
                 .duration(1000)
                 .style('stroke', '##c85951')
                 .remove();
            console.log('Removed')

            // For each new contig define a new group <g> svg element. 
            // This group elements will allow for text labels.
            // d3.force will assign this group x-y coordinates.
            pairs2 = pairs.enter().append('g')
                .attr('class', 'pairs2')
                .attr('length', function(d) {d.length}); // Refactor to contigs?

            // Append the line and text properties to the group elements.
            pairs2.append('line')
                // d3-selection selection.on
                //.on('mouseover', function(d) {
                //    if (mouseEvent != 'Drag') {
                //        console.log('hover');
                //        console.log(d3.select(this));
                //        d3.select(this).style('stroke','#D46D6A');
                        //ticked(); // Why was this here in the first place
                //    }
                .attr('value', function(d) {d.length})
                .on('mouseover', mouseOver)
                .on('mouseout', function(d) {
                    if (mouseEvent != 'Drag') {
                        d3.select(this).style('stroke', '' );
                        //ticked();
                    }
                })
                // d3-selection "selection.call"
                // d3-drag "drag.on"
                .call(d3.drag()
                       .on("start", dragstarted)
                       .on("drag", dragged)
                       .on("end", dragended));
                console.log(pairs2.call(d3.drag()));
            // Appending data here for mouseover retrieval
            pairs2.append('text')
                .text(function(d) {return d.source});
            pairs2.append('length')
                .text(function(d) {return d.length});
            pairs2.append('coverage')
                .text(function(d) {return d.coverage});

            // Merge the new pairs into the main pair selection
            pairs = pairs.merge(pairs2);

            // Scaling the lengths to ensure that the contigs will fit on in the 
            // SVG canvas.
            var lengthScale = d3.scaleLinear()
                .domain([0, d3.max(d.contigData, function(d) {
                    return d.length;
                })])
                .range([5,256]); // Range 5 - 250 px

            /* Select and join the contig adjacencies */
            // Bind the data
            links = links.data(d.contigLinks);
            
            // When no new contigs are detected, then we will ensure
            // that the colour for the new contigs are not changed
            if (links.enter().size() != 0) {
                links.attr('class', 'links');
            }
            // Remove the links with no data
            links.exit()
                 .transition()
                 .duration(1000)
                 .style("fill-opacity", 1e-6)
                 .remove();

            // For each new contig define a new svg element
            var links2 = links.enter().append('g')
                .attr('class','links2');
            
            // Append attributes
            links2.append('line');
            links = links.merge(links2)
            
            /* Restart the simulation */
            visual.nodes(d.nodes);

            // Draw the contig
            visual.force('pairs')
                .links(d.contigData)
                .distance(function(d,i) {
                    //console.log(d);
                    return lengthScale(d.length);
                })
                .iterations(40); // Enforce the distance (adds runtime cost)

           // Draw the contig adjacencies
            visual.force('link')
                .links(d.contigLinks)
                .distance(5)            // Also reduce the distance between adj edges
                .iterations(10);         // Maybe add as a user setting

            /**
             * Specify forces between nodes to prevent them from stacking on each
             * other.
             * Negative strength = repulsion.
             * Positive strength = attraction.
             * manyBody.distanceMin and manyBody.distanceMax used to localise
             * the forces between nearby nodes instead of over the whole
             * visualisation
             */
            visual.force("charge")
                .strength(-180)
                .distanceMin(45)
                .distanceMax(100); // Selected based on trial and error
        }

        /**
         * On every 'end' we run the folliowing.
         * 'end' refers to the end of 
         */
        function ticked() {
            /*
             * Start the real-time visualisation
             */

            // Add transitions and update the svg elements
            //pairs.select('line').transition().duration(2000)
            pairs.select('line')
                .attr('x1', function(d) { return d.source.x;})
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });

            // Add transitions and update the svg elements
            //pairs.select('text').transition().duration(2000)
            pairs.select('text')
                .attr('x', function(d) { return (d.source.x + d.target.x)/2;})
                .attr('y', function(d) { return (d.source.y + d.target.y)/2; });

            // Add transitions and update the svg elements
            //links.select('line').transition().duration(2000)
            links.select('line')
                .attr('x1', function(d) { return d.source.x; })
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });
                    
           // }); // End force.on anon function
        }

        /**
         * On every 'end' we run the folliowing.
         * 'end' refers to the end of 
         */
        function end(transitionTime) {
            /*
             * Start the real-time visualisation
             */

            // Add transitions and update the svg elements
            pairs.select('line').transition("drawpairs").duration(transitionTime)
                .attr('x1', function(d) { return d.source.x;})
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });

            // Add transitions and update the svg elements
            pairs.select('text').transition("drawtext").duration(transitionTime)
                .attr('x', function(d) { return (d.source.x + d.target.x)/2;})
                .attr('y', function(d) { return (d.source.y + d.target.y)/2; });

            // Add transitions and update the svg elements
            links.select('line').transition('drawline').duration(transitionTime)
                .attr('x1', function(d) { return d.source.x; })
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });
                    
           // }); // End force.on anon function
        }

function mouseOver(d) {
    if (mouseEvent != 'Drag') {
        console.log('hover');
        console.log(d3.select(this));
        //console.log(d3.select(this).select('text').text(function(d) {return d.source}));
        console.log(d3.select(this.parentNode).text());
        //d3.select(this).style('stroke','#50446d');
        d3.select(this).style('stroke','#D46D6A');
        //ticked(); // Why was this here in the first place
        document.getElementById("cName").innerHTML = d3.select(this.parentNode).select('text').text()
        document.getElementById("cLength").innerHTML = d3.select(this.parentNode).select('length').text() + ' bp'
        document.getElementById("cCoverage").innerHTML = d3.select(this.parentNode).select('coverage').text()
    }
}

// Somehow dragstart prevents force layout from changing the position after
//https://bl.ocks.org/mbostock/3750558
function dragstarted(d) {
    mouseEvent = 'Drag';
    timerRestart = 30;
    stopUpdates();
    stopAnimation();
  if (!d3.event.active) visual.alphaTarget(0.0025).restart();
  d3.select(this).style('stroke','#D46D6A');
    visual.on('tick', ticked);
    visual.on('end', null);
    console.log('dragstart');
    console.log(d3.event.x);
    console.log(d3.event.y);
    console.log(d.source.x);
    console.log(d.source.y);
    console.log(d3.event.x - ((d.source.x + d.target.x)/2))
    console.log(d3.event.y - ((d.source.y + d.target.y)/2))

    // Calculate the offset between the click location and the two end-points.
    // This will be used to offset the end-point locations in the dragged()
    // callback.
    offsetsx = d3.event.x - d.source.x;
    offsetsy = d3.event.y - d.source.y;
    offsettx = d3.event.x - d.target.x;
    offsetty = d3.event.y - d.target.y;

    // Fix the endpoint for user interaction.
    d.source.fx = d.source.x;
    d.source.fy = d.source.y;
    d.target.fx = d.target.x;
    d.target.fy = d.target.y;
}

/**
 * Callback function for when the mouse is dragged on a 'contig'.
 * Notes: Calculate the offsets at dragstarted() then apply them here.
 * Any positional offset calculations done here may cause some funky jitter.
 */
function dragged(d) {
    d3.select(this).style('stroke','#D46D6A');
    d.source.fx = d3.event.x - offsetsx;
    d.source.fy = d3.event.y - offsetsy;
    d.target.fx = d3.event.x - offsettx;
    d.target.fy = d3.event.y - offsetty;
    console.log('dragged');
}

// The handling of animations for these functions is still a bit of a hack
function dragended(d) {
    // This causes bugs since mouseover/mouseout will trigger ticked() before
    // the transitions in end() has completed.
    //visual.on('tick', null);
    //visual.on('end', end(2000));
    mouseEvent = 'Null';
    
  if (!d3.event.active) visual.alphaTarget(0);
  //d3.select(this).classed("fixed", d.fixed = false);
    var offsetx = d3.event.x - ((d.source.x + d.target.x)/2)
    var offsety = d3.event.y - ((d.source.y + d.target.y)/2)
    console.log('dragended');
    console.log(d3.select(this));

    // Set to null so that d3.force can reposition the elements
    d.source.fx  = null;
    d.source.fy = null;
    d.target.fx  = null;
    d.target.fy = null;

  //d3.select(this).classed("fixed", d.fixed = false);
  d3.select(this).style('stroke', '#6F90A2' );
  startAnimation(d);
  startUpdates();
} // dragended(d)

function getTransitionTime() {
    return 2000;
}

function dynamicUpdate() {
    console.log('Running');
     /* Static mode */
    if (dynamic == 0 ) {
        document.getElementById("timer").innerHTML = "Static mode"; // does not work?
    } 
    /* Real-time */
    if (dynamic == 1 ) {
        visual.on('tick', null);
        visual.on('end', function() {end(2000)});
        ///* Read the JSON file located in the same directory */
        d3.json("assembly.json", function(error, d) {
        
        if (error) throw error;

        /* Update the data using the JSON */
        update(d);
        /* Re-energise the simulation */
        visual.alpha(1).restart();
        seconds = 10; // Not timer not accurate due to 'end' update oddness.

        }); // End d3.json read
    }
}

function startAnimation(d) {
    console.log('Transitions reset.');
    uiIdleTimer = setTimeout(function() {
        visual.on('tick', null);
        visual.on('end', function() {end(2000)});
        //update(d);
        visual.alpha(1).restart();
        console.log('Transitions readded.');
    },10000);
}

function stopAnimation() {
    console.log('clearTimeout.');
    clearTimeout(uiIdleTimer);
}

function stopUpdates() {
    clearInterval(updater);
}

function startUpdates() {
    console.log('restart sim.');
    updater = setInterval(function() {dynamicUpdate()},10000);
}

function incrementClock() {
    clock = clock + 1;
    console.log(clock);
}
        </script>
        </div> <!--id=npDash-->
    </body>
</html>